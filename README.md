# JavaTechnologies

## Lab 1 - Work
  * Created the servlet in accordance with the first bullet point from the lab page.
  * Reconfigured response content(just text, no html) for requests from desktop applications.
  * Used JMeter for testing the performance and concurrency with different values for mock and sync parameters and saved results in csv files. (1000 http requests per scenario)
  * Create a python project that reads the csv files content and compute the average latency of the requests for all the different scenarios.
## Lab 2 - Work
  * Created the server-side components and jsp pages in accordance with the first bullet point from the lab page
    - Created the "ControllerServlet" component with the goal of managing the web-flow in the application (handling requests/responses, forwarding etc.)
    - Created the model class "Record"
    - Created the model class "Category"
    - Created the "RecordFileRepository" component with the goal of handling record model operations and file data access.
    - Created the "input" jsp file that contains a form for posting records.
    - Created the "result" jsp file that contains a table with the current records contained in the server data storage. The data is displayed using jstl core tags
## Lab 3 - Work
  * Created the jsf pages, beans, jdbc connection and other server-side components in accordance with the first bullet point from the lab page.
    - Created the "exam.xhtml" jsf page with the purpose of displaying the existing exams using the jsf core and html library. The information is displayed in a data table.
    - Created the "students.xhtml" jsf page with the purpose of displaying the existing students using the jsf core,html and facelets library. The information is displayed in a data table.
    - Created the model class "Exam" and annotated it with "@Named" and "@SessionScoped" with the purpose of being viewed as a bean.
    - Created the model class "Student" and annotated it with "@Named" and "@SessionScoped" with the purpose of being viewed as a bean.
    - Created the model class "Session" and annotated it with "@Named" (with a custom name) and "@SessionScoped" with the purpose of being viewed as a bean. Specific for this class are the services that are injected using the @Injected annotation and the "init()" method annotated with @PostConstruct. The main purpose for this additional functionality is to provide the bean a safe use of depedencies (ExamService, StudentService) only after the bean is initialiazed. The "init()" method is called only once when the bean is first referenced in a page.
    - Created the SingletonRepository class that is designed using the Singleton pattern and contains functionality for retrieving information from a PostgreSQL database. The connection is established using PostgreSQL jdbc driver.
    - Created the ExamService class with the purpose of creating an intermediary between the data acces repository and the model class removing the unwanted depedency between a model class and external details like database access service. Exams information is obtained through the SingletonRepository instance.
    - Created the StudentService class with the purpose of creating an intermediary between the data acces repository and the model class removing the unwanted depedency between a model class and external details like database access service. Students information is obtained through the SingletonRepository instance.
    - (Side note: Unfortunately, I encountered several configuration problems when using the frameworks Primefaces and Bootsfaces but I hope to find a solution for the next laboratory.)
  
Note: I don't know what happened, but somehow the explanations for Lab 4 and Lab 5 vanished from the readme.md file. I will try to recover it, but this was an unexpected behaviour.

Another note: I managed to find the issue for the database exceptions when I presented the work for lab 5. The "META-INF" folder with the persistence.xml file was not in the right location. Relocated it to src/main/resources and now the jda data source togheter with the declared entities are now successfully identified.

## Lab 6 - Work
 - Created the jsf reservation.xhtml file that shows the resources and their quantities registered in the database. Using this page, the user can select one of the exams registered in the database using "<p:selecteOneMenu>" tag and assign the number of resources required for a exam. The desired quantity for a certain resource can be typed in that resource input text. If a resource quantity is not available (i.e. the quantity is lower than or equal to 0) that resource group tags will not be rendered.
 - Refactored the ExamsRepository and StudentsRepository to be EJBs by adding the @Stateless annotation and injecting them in their respective services(ExamService, StudentService) using the @EJB annotation.
 - Created the ResourceRepositoryStateless class and annotated it with @Stateless in order to be considered an ejb. Declared an EntityManager object annotated with the @PersistenceContext followed by the name of the PersistenceUnit declared in persistence.xml. Implemented the "isResourceAvailable" method that checks if the quantity for a given paramater of type Entity.Resource is greater than 0; if that's the case, the method returns true. Also implemented the method getResources in order to initialiaze the reservation page with the resources name registered in the database, togheter with their quantities.
 - Created the ResourceRepositoryStateful class and annotated it with @Stateful in order to be considered an ejb. Declared an EntityManager object annotated with the @PersistenceContext followed by the name of the PersistenceUnit declared in persistence.xml. Implemented the "assignResources" method that receives as parameters a list of objects of type Entity.Resources, the exam that will the resources be allocated to, and a list of quantities that represents each resources selected quantities for that exam. In the method body, the exam is assigned to every resource in the list, followed by the new quantities. The newly quantities are computed by substracting from the database registered quantity for that resource the selected quantity by the user. For both ResourceRepositoryStateful and ResourceRepositoryStateless, because there was not specificed, the default container-managed transaction is used and all the methods, by default, have transaction type required attribute.
 - Created the SingletonResourceLog class and annotated it with @Singleton in order to be considered an ejb. Followed by the @Singleton annotation is the @Startup annotation that forces the initialization the singleton bean upon application startup. The initialization is done in the "init" method annotated with @PostConstruct. The body of the method uses the injected ResourceService instance using the @Inject annotation to get the resources registered in the database. Then, the Map<String, String> resourceMap declared, stores as keys the resources names and as values the exams names. Another two methods were implemented and those are "updateMap" and "updateMapList". Their functional purpose is the same but they have different parameters types(Resource vs List<Resource>). In order for the methods to be concurrently accesed, the @Lock(LockType.WRITE) annotation was added. Given the default context regarding concurrency, the container-managed concurrency is the container default and the locks annotations are properly used.

## Lab 7 - Work
 - Created the login, register xhtml files in order to provide the user with means of registering and logging into the application. The welcoming file for the application is represented by the login xhtml file. On the login page, the user can navigate to the register page by pressing the register button or he can press the login button and navigate futher into the application if the introduced credentials are correct.
 - Created the homeAdmin, homeAuthor, homeReviewer xhtml files which provides to the user with content specific to the user role (admin, author, reviewer). Navigation to those files is done from the login page and the navigation rules are set in the faces-config.xml file.
 - Created the entity class User and created two named quaries in order to retrieve all the users from the database and check if the there exists a user in the database with the given credentials.
 - Created the LoginBean and RegisterBean classes that represent CDI beans scoped on session level. Inside those classes, the loginUser() method and registerUser() method were created that uses an User service in order to retrieve the desired informations from the infrastructure level. The service is injected using the @Inject annotation.
 - Created the UserService class in order to facilitate the communication between the a user repository injected with @Inject annotation and the login and register beans. Inside this class, the registerUser() and loginUser() were created with the purpose of calling the repository methods with (almost) the same name.
 - Created the UserRepository class in order to query or update the database using an EntityManager object annotated using @PersistenceContext. The repository is a CDI bean scoped on application level and because of that the @Transactional annotation was used on the userLoggedIn and registerUser methods.
 - I will continue working on the other laboratory bullet points.

## Lab 8 - Work
 - Created the ApplicationConfig class with the purpose of configuring the application path for accessing jax-rs services. As such, all http calls to the services will have the prefix "api".
 - Created the AddDocumentService class with the purpose of providing the necessary functionality for adding documents. "@Path" annotation was used at class level in order define the resource location for adding documents. Created the "addDocument()" method annotated with "@Post" and because it receives a http json body it was annotated with "@Consumes(MediaType.APPLICATION_JSON)". Also, the http response contains the created document so the "@Produces(MediaType.APPLICATION_JSON)" was added at method level. The method was documented using OpenApi annotations "@APIResponses" and "@Operation" for describing the http responses and method purpose.
 - Created the DeleteDocumentService class with the purpose of providing the necessary functionality for deleting documents.  Created the "deleteDocument()" method annoted with "@DELETE" and extended the path with an id parameter using "@Path("/{id}")". This method calls the documents repository delete method and returns a 204 No Content response status code using Response.build() method. The method was documented using OpenApi annotations "@APIResponses" and "@Operation" for describing the http responses and method purpose.
 - Created the UpdateDocumentService with the purpose of providing the necessary functionality for updating documents. Created the "updateDocument" method annotated with "@PUT" and because the method paramater is the http request json body it was annotated with "@Consumes(MediaType.APPLICATION_JSON)". Also, the method returns the updated document so the "@Produces(MediaType.APPLICATION_JSON)" was used for adding the required "ContentType" header value for the http response. The method was documented using OpenApi annotations "@APIResponses" and "@Operation" for describing the http responses and method purpose.
 - Created the ViewDocumentService with the purpose of providing the necessary functionality for viewing all the documents and viewing user specific documents. Created the "getDocuments()" method for getting all the documents from the database and annotated it with "@GET". Due to the fact that we want to return a http response as a json array containing a list of the documents the "@Produces(MediaType.APPLICATION_JSON)" annotation was used. The method was documented using OpenApi annotations "@APIResponses" and "@Operation" for describing the http responses and method purpose. Created the "getUserDocuments()" method for getting all the documents specific to a certain user. In order to retrieve all the documents for a given user, the "@Path("/{id}") for user identification. Same as the "getDocuments()" method, the "@Produces(MediaType.APPLICATION_JSON)" annotation was used and it was documented with OpenApi annotations.
  - Created the "CacheStore" class with the purpose of holding information about the GET http request path parameter for viewing documents and of holding the response in the form of a list of documents.
  - Created the ViewDocumentsServiceFilter class that implements the ContainerResponseFilter and override the "filter()" method. Due to the fact that the class implements the ContainerResponseFilter, the "filter()" method code will execute after a response will be sent back to the client. Inside the method, we check if the request method type is "GET" and, if that's the case, we store inside the "cache" list the path parameter(userId) followed by the http response from the server and that is the list of documents specific to that userId. 

## Lab 9 - Work
 - Configured using glassfish admin interface jdbc realm authentication for the application using the existing ```file``` jdbc realm. For this realm, there were created the appadmin, appauthor and appreviewer groups and several test users assigned to those groups. In order to map the roles names in the application with the configured group names, there were added ```security-role-mapping``` tags inside the ```glassfish-web.xml``` for mapping ```appadmin``` to role ```admin```, mapping ```appauthor``` to role ```author``` and mapping ```appreviewer``` to role ```reviewer```. The aforementioned roles were defined in the ```web.xml``` file using ```security-role``` tag. Also, in the same file, ```security-constraints``` tags were defined in order to control access to the web resources. As such, users with ```admin``` role were constrained on accesing only resources located in the ```/admin/*``` folder, users with ```author``` role on accessing only resources located in the ```/author/*``` folder and users with ```reviewer``` role on accessing only resources located in the ```/reviewer/*``` folder. Each role can only acces their own specific home page as dictated by the jdbc realm authentication process.
 - In order to secure the REST services and bussines logic components, the ```@RolesAllowerd``` annotation was used at class level and also on method level for certain role specific functionalities. For instance, the ```ViewDocumentService``` class is annotated with ```@RolesAllowed({"author","admin","reviewer"})``` but only the admin can view all the documents from the database so the ```getAllDocuments()``` method was annotated with ```@RolesAllowed({"admin"})``` overriding the class level annotation.
 - Created an Eclipse Micropofile project using IDE(Intellij) support with Payara-Micro server implementation. The IDE generated two projects, Service-a and Service-b. Inside the Service-a project the Documents REST resource are added and configured. Service-b project was created in order to test the communication between the two microservices. 
 - For Service-a project, the ```JavaLab9EERestApplication``` generated file was modified in order to configure the application path as ```api/v1```. The ```DocumentsController``` class was created exposing rest endpoints for accessing CRUD functionalitites for documents and the ```Path("/documents")``` annotation was added at class level. At the same time, dependencies were added on all documents crud services in order to be used inside controller methods. The document services classes and the document repository class added to this project are the same one as in the previous lab.<br/>For running the Service-a project, the project jar file was generated inside the target folder by using the ```mvn clean package``` command. After that, the Payara Micro server was started by running the ```java -jar target/JavaLab9EE-microbundle.jar``` command.
 - For Service-b project, the ```TestController``` class was created in order to test the communication between the two microservices. Inside this class, the ```callServiceA()``` method creates a new client that invokes the Service-a microservice by sending a http GET request to one of the endpoints from Service-a. Also, the response is logged for testing purposes.<br/>For running the Service-b project, the same commands for Service-a were used but in different locations in the file system.
 - Due to Payara Micro specifications, Glassfish functionalities for configuring the Connection pools and JNDI resources using the admin interface were not present in this context so the Postgre database access was configured using a different approach. Those resource configurations were made after booting Service-a using an additional java command option ```--postbootcommandfile``` . The received value for this command option is the path to the ```post-boot-commands.txt``` file defined under the service-a project file. The content of this file is represented by the commands for creating the connection pool followed by setting the property values for our connection pool(server name, password, database, port number and username). After the connection pool was configured, commands for creating the db jdbc resource and creating the reference for the resource were added.<br/>An interesting fact related to Payara Micro server implementation is that the root rest endpoints detected by the server will not detect endpoints defined with ```jakarta.wr.rs.Path``` annotation, only with ```javax.wr.rs.Path```. Unfortunately, I couldn't find the reason for this but it took a lot of time for figuring it out.
 - Both microservices and the database were deployed using Docker containers. For deploying the Postgre database using a Docker container, the command ```docker run --name student -p 5432:5432 --network=bridge -e POSTGRES_PASSWORD=student -d postgres``` was used. The Postgre docker image is downloaded automatically if it isn't found. For both Service-a and Service-b docker files were created in order to build docker images for each of them by using ```docker build -t micro-payara .``` command and ```docker build -t micro-payara-secondary .``` command. Those docker files were defined under each project folder(that's why '.' is used). In order to add the configuration commands for the Postgre connection pool mentioned earlier, the ```post-boot-commands``` path file was added inside the Service-a docker file as an environment variable for the docker container. In order to create the containers for both the services the command ```docker run -d -p 8080:8080 --network=bridge --name payara micro-payara``` and command ```docker run -d -p 8180:8180 --network=bridge --name payara-secondary micro-payara-secondary``` were run. The network command option was added with the value "bridge" in order for the microservices and the database to communicate with each other through their respective containers.

## Lab 10 - Work
 - The docker containers for the microservices and database were created during previous laboratory. All details may be found at the end of laboratory 9 work description.
 - Used IDE support in order to generate the ```ResilienceController``` class togheter with an already constructed method for illustrating ```@Fallback``` annotation behaviour when a certain request timeout is reached.<br/>Created the ```fallbackWithRetryTest()``` method for testing request timeout behaviour with a number of retries. The ```@Retry(maxRetries = 2, delay = 200, jitter = 50)``` annotation was used on this method with ```@Timeout(5000)``` annotation. By calling this endpoint, it will retry for 2 times after passing the 5000 ms timeout so after ~ 15000ms(15s) the fallback method defined will be called. The delay between retries is 200ms and the delay between sending packets is 50ms(jitter).<br/>Created the ```bulkheadSemaphoreTestWithFallback()``` method with a corresponding fallback method. Because the method execution is Synchronous, after 3 maximum allowed concurrent requests the 4 request will instantly receive a response with the fallback method return response. The maximum allowed concurrent requests is established using ```@Bulkhead(3)``` annotation.<br/>Created the ```bulkheadThreadPoolTestWithFallback()``` method with a corresponding fallback method. Because the method execution is asyncronous, if 3 requests are waiting for a reponse and 5 are in queue then the 9 requests will instantly receive a response with the fallback method return response.
